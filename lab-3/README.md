# Структуры данных

## Задачи

* Протестировать некоторые структуры для хранения данных в Java на скорость выполнения операций.
* Вывести таблицу с результатами.
* Разделить код для тестирования и вывода таблицы на набор коротких static-функций. Желательно осмысленно распределить функции между несколькими классами.
* Объяснить результаты тестов.

## Структуры

Рассматривать будем обычный массив и самые популярные реализации интерфейсов List и Set, хранящие числа от 0 до N - 1.

Всего наберется шесть структур для тестирования:

1. Integer[] - обычный массив. Т.к. List и Set не могут содержать примитивные int, массив тоже будет содержать ссылочный тип Integer.
2. ArrayList\<Integer\> - самая часто используемая списочная структура, использующая обычный массив под капотом.
3. ArrayList\<Integer\> с заданным размером. При создании экземпляра ArrayList в параметрах конструктора можно указать изначальный размер внутреннего массива, что мы и делаем.
4. LinkedList\<Integer\> - реализация двунаправленного связного списка.
5. HashSet\<Integer\> - самая популярная реализация Set. Группирует элементы по hashCode().
6. TreeSet\<Integer\> - еще одна реализация Set. Строит дерево из хранимых объектов на основе их hashCode().

## Тесты

Каждый тест представляет собой повторение одной операции по N раз для каждой структуры. Для каждого теста стоит подобрать такое N, чтобы результаты стали стали различимы (если время выполнения для каждой структуры от 0 до 5 миллисекунд разница в их производительности куда менее очевидна, чем если она варьируется между 10 и 500 миллисекундами).

Для некоторых структур некоторые тесты проводить бессмысленно, в этом случае в результатах указываем для таких тестов прочерк.

1. Вставка в начало списка.
   Создаем структуру и начинаем добавлять в нее по одному числа от 0 до N-1 на нулевое место. Замеряем время добавления всех чисел.
   Т. к. Set не имеют порядка элементов для них это тест не проводи.
   Т. к. вставка в обычный массив несколько бессмысленна и требует множество дополнительных действий по перемещению уже имеющихся чисел, то для него тоже не проводим этот тест.
2. Вставка в середину списка.
   Создаем структуру и начинаем добавлять в нее по одному числа от 0 до N - 1 на место ровно в середине текущего числа элемента.  Замеряем время добавления всех чисел.
   Пример: вставляем число 9. Значит в списке уже числа от 0 до 8, то есть 9 штук. Число 9 вставляем на место номер 9 / 2 = 4. Затем число 10 вставляем на место номер 10 / 2 = 5, число 11 на место 11 / 2 = 5 (число 10 вытесняется на 6 место) и т.д.
   Аналогично вставке в начало тест не имеет смысла для массива и set-ов.
3. Вставка в конец списка.
   Создаем структуру и начинаем добавлять в нее по одному числа от 0 до N - 1 без указания места (исключение - массив. Для него придется использовать итерируемый индекс для вставки чисел на каждое место в массиве последовательно).
   Замеряем время добавления всех чисел.
   Формально для set-ов не существует порядка элементов, будет считать для них обычную вставку вставкой в конец.
4. Удаление из начала списка.
   Создаем структуру и начинаем добавляем в нее числа от 0 до N - 1.
   Затем поочередно удаляем из структуры элемент на нулевом месте
   Замеряем время удаления всех чисел.
   Аналогично вставке в начало тест не имеет смысла для массива и set-ов.
5. Удаление из середины списка.
   Создаем структуру и начинаем добавляем в нее числа от 0 до N - 1.
   Затем поочередно удаляем из структуры элемент в середине оставшейся части. Если в списке осталось N элементов, то удаляем элемент под номером N / 2.
   Замеряем время удаления всех чисел.
   Аналогично вставке в начало тест не имеет смысла для массива и set-ов.
6. Удаление из конца списка.
   Создаем структуру и начинаем добавляем в нее числа от 0 до N - 1.
   Затем поочередно удаляем из структуры элемент на последнем месте
   Замеряем время удаления всех чисел.
   Аналогично вставке в начало тест не имеет смысла для массива.
7. Получение всех элементов. Создаем структуру и начинаем добавляем в нее числа от 0 до N - 1. Поочередно получаем все из списка элементы по индексу (для сетов вызываем contains для всех добавленных в него чисел). Замеряем время получения (проверки на вхождение) всех чисел.

## Требования

* Должен существовать метод, который получает на вход двумерный массив строк и выводит его как хорошо оформленную таблицу с разделительными линиями и шириной каждого столбца, равной самой длинной строке в этом столбце.
* У вас должен существовать класс, который содержит результаты тестов по одной операции. В нем хранится имя протестированной операции и результат по каждой протестированной структуре. Это может быть как обычный класс с неизменяемыми полями, так и record-класс.
* Должен быть реализован метод, который преобразует список списке результатов тестов в двумерный массив строк для последующего вывода в виде таблицы.
* Выводимая таблица должна содержать:
  * в верхней строке список тестируемых структур
  * в левой колонке список операций, для которых провели тесты. В скобках у каждой операции указано число элементов в структурах, с которым проводили тест
  * на пересечении - время исполнения теста для конкретной структуры в миллисекундах
* Добавьте в проект текстовый файл, в который скопируйте сформированную вами таблицу (будем смотреть на нее во время сдачи)
* (Опционально) Выводимые числы должны разделяться символом “_” каждые три разряда.
* (Опционально) Если текст в ячейке таблицы заполняет не всю ячейку, то он должен быть выровнен по центру ячейки.
