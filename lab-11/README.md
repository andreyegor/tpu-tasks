# [Японский кроссворд](https://docs.google.com/document/d/1oEb4QawwUwvPr6ookD8S0eZAqN42_3Cf4FgU2TyOLiY/edit?tab=t.0#heading=h.aq2apc3pvmq3)

Вопреки своему названию, никаких слов в японском кроссворде нет. На "пиксельном" монохромном поле необходимо нарисовать изображение, зашифрованное в цифрах на полях. Подробные правила можно почитать на [Википедии](https://ru.wikipedia.org/wiki/%D0%AF%D0%BF%D0%BE%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D0%BA%D1%80%D0%BE%D1%81%D1%81%D0%B2%D0%BE%D1%80%D0%B4).

В рамках этой работы реализуем японский кроссворд средствами Canvas.

## Этап 1. Хранение и чтение изображения

Ваше приложение на запуске должно открывать файлы, содержащие кроссворд. Вам придется продумать формат для хранения этого файла. Очевидно, что хранить в нем “квадратный” текст из пробелов и символа █ плохая затея - “игрок” может просто открыть ваш файл в блокноте и увидеть изображение, но мы можем пренебречь этой проблемой.

Файлы должны поддерживать изображения разного размера, предельные значения для размеров можете задать сами.

После того как вы создадите несколько файлов придется научить ваше приложение читать их и сохранять информацию в каких-то внутренних классах. При чтении должны просчитываться числа слева и сверху от поля (соответственно, в файле они храниться не должны, только само изображение)

## Этап 2. Отрисовка поля

Отрисовываем считанное изображение на Canvas. Не стесняйтесь плодить классики, каждый из которых отвечает за отрисовку своей части поля.

Помним о том, что изображение может быть разных размеров, может потребоваться изменить размер окна. Еще было бы неплохо запретить пользователю менять размер окна.

Сразу можно учесть, что у клетки на самом деле 3 состояния - белая, черная, и белая с точкой, так что учимся рисовать их все.

## Этап 3. Обработка действий

Начинаем обрабатывать клики мышкой по полю. Для этого вешаем на Canvas “слушатель” нажатий.

В функции, которая будет вызываться по клике, мы должны определить координаты, по которым находился указатель мыши.
По координатам определяем в какую клетку мы попадаем.
Определяем какой кнопкой мыши мы кликнули, при нажатии левой кнопкой клетка меняет состояние с белого на черное и наоборот, если она не была “заблокирована”, при клике правой кнопкой блокируется\разблокируется.

Если при смене состояния клетки изображение совпало с загаданным, то выводится сообщение о победе и поле блокируется для дальнейших кликов.

## Чеклист

- [X] минимум 2 файла с описанием изображений для кроссвордов разных размеров, добавленные в gitlab
- [X] на старте приложение предлагает выбрать файл
- [X] выбранный файл открывается и для него корректно рассчитываются и отображаются числа-подсказки
- [X] правый клик блокирует\разблокирует клетку
- [X] незаблокированные клетки левым кликом меняют цвет, заблокированные клетки не реагируют на левый клик
- [X] условие победы корректно проверяется и игра заканчивается при его выполнении

## Что еще можно сделать?

Если захочется больше практики или бонусных баллов, то вот что можно сделать:

- [X] Файлы с изображением должны быть тяжело читаемы для пользователя. Можно разработать более хитрый бинарный формат для их хранения. родную сериализацию Java использовать нельзя, т.к. файлы для ранних версий могут оказаться нечитаемыми для более поздних.
- [ ] Автоматически блокировать клетки, если игрок частично или полностью исчерпал подсказки в строке\столбце. Вот в этой строке при проставлении игроком четвертой черной клетки можно все оставшиеся заблокировать.
- [ ] Можно пойти еще дальше и проверять даже частичное “исчерпание”. Например, в строке ниже мы можем гарантированно заблокировать вторую и восьмую клетку, т.к. по подсказками 1 и 5 в этих клетках не может быть черных клеток..
