# Поиск максимального потока в сети (алгоритм Форда-Фалкерсона).

## Теоретическая шпаргалка

Идея алгоритма заключается в следующем. Изначально величине потока присваивается значение f(u,v)=0 для всех u,v из графа V. Затем величина потока итеративно увеличивается посредством поиска увеличивающего пути (путь от источника к стоку, вдоль которого можно послать ненулевой поток).

1. Обнуляем все потоки. Остаточная сеть изначально совпадает с исходной сетью.
2. В остаточной сети находим любой путь из источника в сток. Если такого пути нет, останавливаемся.
3. Пускаем через найденный путь максимально возможный поток:
4. На найденном пути в остаточной сети ищем ребро с минимальной пропускной способностью $c_{min}$.
5. Для каждого ребра на найденном пути увеличиваем поток на $c_{min}$ а в противоположном ему — уменьшаем на $c_{min}$.
6. Модифицируем остаточную сеть. Для всех рёбер на найденном пути, а также для противоположных (антипараллельных) им рёбер, вычисляем новую пропускную способность. Если она стала ненулевой, добавляем ребро к остаточной сети, а если обнулилась, стираем его.
7. Возвращаемся на шаг 2.

## Описание программы

Для поиска пути используется bfs(graph: List[List[int]], source: int, sink: int) -> List[int] | None который возвращает какой-то путь от стока к источнику.

Сам алгоритм

```python
def ford_fulkerson(graph, source, sink):
    graph = deepcopy(graph)
    # Пока существует путь из источника в сток. (2 и 4)
    max_flow = 0
    while reversed_path := bfs(graph, source, sink):
        # Ищем ребро с минимальной пропускной способностью с_min. (3.1)
        min_edge_len = min(
            graph[reversed_path[i + 1]][reversed_path[i]]
            for i in range(len(reversed_path) - 1)
        )

        # Для каждого ребра на найденном пути увеличиваем поток на c_min
        # а в противоположном ему — уменьшаем на c_min. (3.2)
        # Модификация остаточной сети работает неявно - текущая
        # реализация bfs просто не рассматривает поток<0. (3.3)
        for i in range(len(reversed_path) - 1):
            graph[reversed_path[i]][reversed_path[i + 1]] += min_edge_len
            graph[reversed_path[i + 1]][reversed_path[i]] -= min_edge_len

        max_flow += min_edge_len

    return max_flow
```
