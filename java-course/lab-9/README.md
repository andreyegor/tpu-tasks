# [Сериализация](https://docs.google.com/document/d/1uVlyAHfbfiLv3lsPC0cW87Hd6f0-VyAxueUWZtDVkCs/edit?tab=t.0)

Для того чтобы ваше будущее приложение могло отрисовывать композиции из созданных вами геометрических фигур, хорошо бы 

## Задачи
* [X] Дополнить классы фигур, созданных в ходе лабораторных работ 7 и 8, методами и вспомогательными классами для записи их в файл в бинарном виде.

## Цели
* [X] Создать класс-обертку над OutputStream, способный помимо основного функционала OutputStream-а записывать в поток любой Drawable в бинарном виде.

* [X] Создать класс-обертку над InputStream, способный считывать фигуры.

## Требования
* [X] Вы не должны использовать сериализацию Java.

* [X] Ваш OutputStream должен иметь методы: *(один единый метод)*
  * [X] Записать Drawable
  * [X] Записать массив\список Drawable-ов

* [X] OutputStream должен каким-то образом сам определить по классу входного объекта что с ним делать, как именно эту фигуру нужно записывать в файл.

* [X] Аналогично InputStream получает методы:  *(один единый метод)*
  * [X] Считать Drawable
  * [X] Считать массив\список Drawable-ов


* [X] Важно чтобы ваш код остался расширяем без изменения. То есть создание нового класса фигур не должно требовать каких-то дополнительных действий, чтобы новую фигуру можно было записать в файл.

## Пример

У вас есть класс Треугольник, Прямоугольник  и Круг, унаследованные от Фигуры. У них есть общий метод `void writeToStream(OutputStream outputStream);` Этот метод сначала записывает в поток число - код вашей фигуры, уникальное для каждого класса(Треугольник - 1, Прямоугольник - 2, Круг - 3). Затем пишутся данные, необходимые для описания фигуры. 

Тогда:
* Треугольника мы последовательно запишем числа : `1, x1, y1, x2, y2, x3, y3`.
* Для Прямоугольника запишем числа: `2, x1, y1, x2, y2, x3, y3, x4, y4`.
* Для круга: `3, x, y, r`.

Получается для записи нам потребуется один метод, который наследуется во все Фигуры и переопределяется там, а наш OutputStream просто будет вызывать этот метод у отправленных на запись фигур.

Но при чтении получим что-то такое в InputStream-е:

```Java
public Drawable readDrawable() throws StreamCorruptedException {
   Scanner scanner = new Scanner(inputStream);
   int type = scanner.nextInt();
   return switch (type) {
       case Triangle.TYPE -> Triangle.readFromStream(inputStream);
       case Rectangel.TYPE -> Rectangel.readFromStream(inputStream);
       case Circle.TYPE -> Circle.readFromStream(inputStream);
       default -> 
throw new StreamCorruptedException("Unexpected type: " + type);
   };
}
```

В каждом классе есть свой статический метод для чтения экземпляра этого класса и мы вызываем его после того как увидели код, соответствующий этой фигуре. 

Такой подход рабочий, но не расширяемый. Если мы решим добавить новую фигуру, например, Эллипс, то помимо того что нам надо будет создать класс, переопределить в нем все необходимые методы, в т.ч. метод для записи в файл, программисту надо вспомнить что нужно создать какой-то код Фигуры и добавить в метод класса, который он не создавал, в switch обработку этого нового кода. Такой подход считается плохим, т.к. вынуждает программиста знать о неких контрактах, которых он не коснется пока приложение не упадет с StreamCorruptedException.

Чтобы код считался расширяемым, программист добавляющий новую фигуру и пытающийся записать ее в файл еще на этапе кодинга **должен столкнуться с ограничением**, которое не даст ему забыть о таком условии.

Отдельно отмечу проблему с добавлением в switch новой ветки. Если вы написшите несколько фигур, скомпилируете их в библиотеку и начнете распространять, то тот кто воспользуется вашей библиотекой не сможет изменять тот код, который вы уже написали. А значит ваш свитч станет непреодолимым препятствием и пользователю придется полностью скопировать ваш класс, чтобы добавить в него свой функционал. Потому такой подход назовут “не расширяемым”.

Способов решения этой проблемы можно придумать несколько, для начала попробуйте подыскать решение сами. Все инструменты для создания расширяемого решения вам уже знакомы.

## Тестирование
Постоянно вводить кучу данных для запуска подобного приложения будет крайне хлопотно, а если использовать случайные числа, то есть риск в один из запусков поймать ошибку на каких-то специфичных данных и не суметь ее потом воспроизвести и, как следствие, починить.

Потому предлагаю попробовать написать что-то, что очень отдаленно будет напоминать Unit-тесты. Мы напишем код, который проверяет на правильность другой код.

* [X] Реализуйте для Группы метод `boolean contentEquals(Group other)`, который возвращает истину когда все содержимое групп полностью совпадает. *(Реализован метод equals)*

* [X] Создайте класс Generator. В ней создайте следующие статические методы:
  * [X] `Drawable triangle()` -  Возвращает треугольник
  * [X] `Drawable rectangel()` -  Возвращает прямоугольник
  * [X] … еще ряд функций, создающие Фигуры.
  * [ ] Для создания нескольких экземпляров Фигур одного класса можно сделать несколько функций `triangle1()`, `triangle2()` и т.д.
  * [X] `List<Drawable> drawableList1()` - собирает несколько фигур из методов, описаных выше, в список
  * [X] `List<Drawable> drawableList2()` - то же, что и drawableList1, только с другим набором фигур
  * [X] `Group flatGroup()` - возвращает Группу с несколькими Фигурами внутри, полченными из `drawableList1`. 
  * [X] `Group nestedGroup()`- создает Группу, добавляет в нее Фигуры из drawableList1. Создает еще одну Группу еще с Фигурами из drawableList2. Одну Группу добавляет в другу, и возвращает эту матрешку из Групп как результат.

* [X] Все значения при генерации должны быть постоянные, никаких рандомов или параметрирования не добавляйте

* [X] Создайте класс Testing. Добавьте в него статические методы:
  * [X] Берется одна фигура, записывается в файл, считывается из файла. Сравнивается созданная фигура с прочитанной из файла. Результат сравнения пишем в консоль. Повторить для нескольких разных фигур
  * [X] Берем список фигур. Записываем его в файл. Считываем из файла. Сравниваем изначальный список со считанным. Результат пишем в консоль. Повторить для обоих формируемых генератором списков.
  * [X] Берем группу, записываем, считываем, сравниваем с исходной. Пишем результат. Повторить для обеих генерируемых групп.

* [X] В функции main последовательно вызовите все методы из класса Testing. На основании вывода в консоль вы сможете понять верно ли работает ваша сериализация-десериализация. Рекомендую реализовать Генератор и Тестер на ранних стадиях работы и последовательно добиваться верной работы каждого теста
